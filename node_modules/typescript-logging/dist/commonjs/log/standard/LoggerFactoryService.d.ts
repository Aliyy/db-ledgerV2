import { LogFormat, LoggerType, LogLevel } from "../LoggerOptions";
import { LoggerFactory } from "./LoggerFactory";
import { LoggerFactoryRuntimeSettings } from "./LoggerFactoryRuntimeSettings";
import { Logger } from "./Logger";
/**
 * Defines a LogGroupRule, this allows you to either have everything configured the same way
 * or for example loggers that start with name model. It allows you to group loggers together
 * to have a certain loglevel and other settings. You can configure this when creating the
 * LoggerFactory (which accepts multiple LogGroupRules).
 */
export declare class LogGroupRule {
    private _regExp;
    private _level;
    private _loggerType;
    private _logFormat;
    private _callBackLogger;
    /**
     * Create a LogGroupRule. Basically you define what logger name(s) match for this group, what level should be used what logger type (where to log)
     * and what format to write in. If the loggerType is custom, then the callBackLogger must be supplied as callback function to return a custom logger.
     * @param regExp Regular expression, what matches for your logger names for this group
     * @param level LogLevel
     * @param logFormat LogFormat
     * @param loggerType Type of logger, if Custom, make sure to implement callBackLogger and pass in, this will be called so you can return your own logger.
     * @param callBackLogger Callback function to return a new clean custom logger (yours!)
     */
    constructor(regExp: RegExp, level: LogLevel, logFormat?: LogFormat, loggerType?: LoggerType, callBackLogger?: ((name: string, settings: LogGroupRuntimeSettings) => Logger) | null);
    readonly regExp: RegExp;
    readonly level: LogLevel;
    readonly loggerType: LoggerType;
    readonly logFormat: LogFormat;
    readonly callBackLogger: ((name: string, settings: LogGroupRuntimeSettings) => Logger) | null;
}
/**
 * Options object you can use to configure the LoggerFactory you create at LFService.
 */
export declare class LoggerFactoryOptions {
    private _logGroupRules;
    private _enabled;
    /**
     * Add LogGroupRule, see {LogGroupRule) for details
     * @param rule Rule to add
     * @returns {LoggerFactoryOptions} returns itself
     */
    addLogGroupRule(rule: LogGroupRule): LoggerFactoryOptions;
    /**
     * Enable or disable logging completely for the LoggerFactory.
     * @param enabled True for enabled (default)
     * @returns {LoggerFactoryOptions} returns itself
     */
    setEnabled(enabled: boolean): LoggerFactoryOptions;
    readonly logGroupRules: LogGroupRule[];
    readonly enabled: boolean;
}
/**
 * Represents the runtime settings for a LogGroup (LogGroupRule).
 */
export declare class LogGroupRuntimeSettings {
    private _logGroupRule;
    private _level;
    private _loggerType;
    private _logFormat;
    private _callBackLogger;
    constructor(logGroupRule: LogGroupRule);
    /**
     * Returns original LogGroupRule (so not runtime settings!)
     * @return {LogGroupRule}
     */
    readonly logGroupRule: LogGroupRule;
    level: LogLevel;
    loggerType: LoggerType;
    logFormat: LogFormat;
    callBackLogger: ((name: string, settings: LogGroupRuntimeSettings) => Logger) | null;
}
/**
 * Interface for the RuntimeSettings related to LoggerFactories.
 */
export interface LFServiceRuntimeSettings {
    /**
     * Returns all LoggerFactoryRuntimeSettings for all registered factories (ordered by index).
     * @returns {LoggerFactoryRuntimeSettings[]}
     */
    getRuntimeSettingsForLoggerFactories(): LoggerFactoryRuntimeSettings[];
    /**
     * Get the runtimesettings for given LogGroup that is part of given LoggerFactory
     * @param nameLoggerFactory Name of LoggerFactory (can be specified when creating a named loggerfactory, a generated on is used otherwise).
     * @param idLogGroupRule Number representing the LogGroup (LogGroupRule)
     * @returns {LogGroupRuntimeSettings | null} LogGroupRuntimeSettings when found, null otherwise.
     */
    getLogGroupSettings(nameLoggerFactory: string, idLogGroupRule: number): LogGroupRuntimeSettings | null;
    /**
     * Get the runtimesettings for given LoggerFactory name
     * @param nameLoggerFactory Name of LoggerFactory
     * @returns {LoggerFactoryRuntimeSettings | null}
     */
    getLoggerFactoryRuntimeSettingsByName(nameLoggerFactory: string): LoggerFactoryRuntimeSettings | null;
}
/**
 * Create and configure your LoggerFactory from here.
 */
export declare class LFService {
    private static INSTANCE_SERVICE;
    /**
     * Create a new LoggerFactory with given options (if any). If no options
     * are specified, the LoggerFactory, will accept any named logger and will
     * log on info level by default for, to the console.
     * @param options Options, optional.
     * @returns {LoggerFactory}
     */
    static createLoggerFactory(options?: LoggerFactoryOptions | null): LoggerFactory;
    /**
     * Create a new LoggerFactory using given name (used for console api/extension).
     * @param name Name Pick something short but distinguishable.
     * @param options Options, optional
     * @return {LoggerFactory}
     */
    static createNamedLoggerFactory(name: string, options?: LoggerFactoryOptions | null): LoggerFactory;
    /**
     * Closes all Loggers for LoggerFactories that were created.
     * After this call, all previously fetched Loggers (from their
     * factories) are unusable. The factories remain as they were.
     */
    static closeLoggers(): void;
    /**
     * Return LFServiceRuntimeSettings to retrieve information loggerfactories
     * and their runtime settings.
     * @returns {LFServiceRuntimeSettings}
     */
    static getRuntimeSettings(): LFServiceRuntimeSettings;
}
