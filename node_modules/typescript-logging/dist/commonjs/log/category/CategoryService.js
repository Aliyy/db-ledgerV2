"use strict";
var DataStructures_1 = require("../../utils/DataStructures");
var LoggerOptions_1 = require("../LoggerOptions");
var CategoryConsoleLoggerImpl_1 = require("./CategoryConsoleLoggerImpl");
var CategoryDelegateLoggerImpl_1 = require("./CategoryDelegateLoggerImpl");
var CategoryExtensionLoggerImpl_1 = require("./CategoryExtensionLoggerImpl");
var CategoryMessageBufferImpl_1 = require("./CategoryMessageBufferImpl");
var ExtensionHelper_1 = require("../../extension/ExtensionHelper");
/**
 * RuntimeSettings for a category, at runtime these are associated to a category.
 */
var CategoryRuntimeSettings = (function () {
    function CategoryRuntimeSettings(category, logLevel, loggerType, logFormat, callBackLogger) {
        if (logLevel === void 0) { logLevel = LoggerOptions_1.LogLevel.Error; }
        if (loggerType === void 0) { loggerType = LoggerOptions_1.LoggerType.Console; }
        if (logFormat === void 0) { logFormat = new LoggerOptions_1.CategoryLogFormat(); }
        if (callBackLogger === void 0) { callBackLogger = null; }
        this._category = category;
        this._logLevel = logLevel;
        this._loggerType = loggerType;
        this._logFormat = logFormat;
        this._callBackLogger = callBackLogger;
    }
    Object.defineProperty(CategoryRuntimeSettings.prototype, "category", {
        get: function () {
            return this._category;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryRuntimeSettings.prototype, "logLevel", {
        get: function () {
            return this._logLevel;
        },
        set: function (value) {
            this._logLevel = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryRuntimeSettings.prototype, "loggerType", {
        get: function () {
            return this._loggerType;
        },
        set: function (value) {
            this._loggerType = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryRuntimeSettings.prototype, "logFormat", {
        get: function () {
            return this._logFormat;
        },
        set: function (value) {
            this._logFormat = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryRuntimeSettings.prototype, "callBackLogger", {
        get: function () {
            return this._callBackLogger;
        },
        set: function (value) {
            this._callBackLogger = value;
        },
        enumerable: true,
        configurable: true
    });
    return CategoryRuntimeSettings;
}());
exports.CategoryRuntimeSettings = CategoryRuntimeSettings;
/**
 * Default configuration, can be used to initially set a different default configuration
 * on the CategoryServiceFactory. This will be applied to all categories already registered (or
 * registered in the future). Can also be applied to one Category (and childs).
 */
var CategoryDefaultConfiguration = (function () {
    /**
     * Create a new instance
     * @param logLevel Log level for all loggers, default is LogLevel.Error
     * @param loggerType Where to log, default is LoggerType.Console
     * @param logFormat What logging format to use, use default instance, for default values see CategoryLogFormat.
     * @param callBackLogger Optional callback, if LoggerType.Custom is used as loggerType. In that case must return a new Logger instance.
     *            It is recommended to extend AbstractCategoryLogger to make your custom logger.
     */
    function CategoryDefaultConfiguration(logLevel, loggerType, logFormat, callBackLogger) {
        if (logLevel === void 0) { logLevel = LoggerOptions_1.LogLevel.Error; }
        if (loggerType === void 0) { loggerType = LoggerOptions_1.LoggerType.Console; }
        if (logFormat === void 0) { logFormat = new LoggerOptions_1.CategoryLogFormat(); }
        if (callBackLogger === void 0) { callBackLogger = null; }
        this._logLevel = logLevel;
        this._loggerType = loggerType;
        this._logFormat = logFormat;
        this._callBackLogger = callBackLogger;
        if (this._loggerType === LoggerOptions_1.LoggerType.Custom && this.callBackLogger === null) {
            throw new Error("If you specify loggerType to be Custom, you must provide the callBackLogger argument");
        }
    }
    Object.defineProperty(CategoryDefaultConfiguration.prototype, "logLevel", {
        get: function () {
            return this._logLevel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryDefaultConfiguration.prototype, "loggerType", {
        get: function () {
            return this._loggerType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryDefaultConfiguration.prototype, "logFormat", {
        get: function () {
            return this._logFormat;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryDefaultConfiguration.prototype, "callBackLogger", {
        get: function () {
            return this._callBackLogger;
        },
        enumerable: true,
        configurable: true
    });
    CategoryDefaultConfiguration.prototype.copy = function () {
        return new CategoryDefaultConfiguration(this.logLevel, this.loggerType, this.logFormat.copy(), this.callBackLogger);
    };
    return CategoryDefaultConfiguration;
}());
exports.CategoryDefaultConfiguration = CategoryDefaultConfiguration;
/**
 * The service (only available as singleton) for all category related stuff as
 * retrieving, registering a logger. You should normally NOT use this,
 * instead use CategoryLoggerFactory which is meant for end users.
 */
var CategoryServiceImpl = (function () {
    function CategoryServiceImpl() {
        this._defaultConfig = new CategoryDefaultConfiguration();
        // All registered root categories
        this._rootCategories = [];
        // Key of map is path of category
        this._categoryRuntimeSettings = new DataStructures_1.SimpleMap();
        // Same, but these are never changed and are used to restore the previous state by the CategoryLoggerControl.
        this._categoryOriginalRuntimeSettings = new DataStructures_1.SimpleMap();
        // Key is name of root logger.
        this._rootLoggers = new DataStructures_1.SimpleMap();
        // Private constructor
        ExtensionHelper_1.ExtensionHelper.register();
    }
    CategoryServiceImpl.getInstance = function () {
        // Load on-demand, to assure webpack ordering of module usage doesn't screw things over
        // for us when we accidentally change the order.
        if (CategoryServiceImpl._INSTANCE === null) {
            CategoryServiceImpl._INSTANCE = new CategoryServiceImpl();
        }
        return CategoryServiceImpl._INSTANCE;
    };
    CategoryServiceImpl.prototype.getLogger = function (root) {
        if (!this.rootCategoryExists(root)) {
            throw new Error("Given category " + root.name + " is not registered as a root category. You must use the root category to retrieve a logger.");
        }
        var pair = this._rootLoggers.get(root.name);
        if (pair != null) {
            return pair.y;
        }
        var logger = new CategoryDelegateLoggerImpl_1.CategoryDelegateLoggerImpl(this.createRootLogger(root));
        this._rootLoggers.put(root.name, new DataStructures_1.TuplePair(root, logger));
        return logger;
    };
    /**
     * Clears everything, including a default configuration you may have set.
     * After this you need to re-register your categories etc.
     */
    CategoryServiceImpl.prototype.clear = function () {
        this._rootCategories = [];
        this._categoryRuntimeSettings.clear();
        this._categoryOriginalRuntimeSettings.clear();
        this._rootLoggers.clear();
        this.setDefaultConfiguration(new CategoryDefaultConfiguration());
    };
    CategoryServiceImpl.prototype.getCategorySettings = function (category) {
        return this._categoryRuntimeSettings.get(category.getCategoryPath());
    };
    CategoryServiceImpl.prototype.getOriginalCategorySettings = function (category) {
        return this._categoryOriginalRuntimeSettings.get(category.getCategoryPath());
    };
    /**
     * Set the default configuration. New root loggers created get this
     * applied. If you want to reset all current loggers to have this
     * applied as well, pass in reset=true (the default is false). All
     * categories will be reset then as well.
     * @param config New config
     * @param reset Defaults to false. Set to true to reset all loggers and current runtimesettings.
     */
    CategoryServiceImpl.prototype.setDefaultConfiguration = function (config, reset) {
        var _this = this;
        if (reset === void 0) { reset = false; }
        this._defaultConfig = config;
        if (reset) {
            // Reset all runtimesettings (this will reset it for roots & children all at once).
            var newRuntimeSettings_1 = new DataStructures_1.SimpleMap();
            var newOriginalRuntimeSettings_1 = new DataStructures_1.SimpleMap();
            this._categoryRuntimeSettings.keys().forEach(function (key) {
                var setting = _this._categoryRuntimeSettings.get(key);
                if (setting !== null) {
                    var defSettings = _this._defaultConfig.copy();
                    var settings = new CategoryRuntimeSettings(setting.category, defSettings.logLevel, defSettings.loggerType, defSettings.logFormat, defSettings.callBackLogger);
                    var defSettingsOriginal = _this._defaultConfig.copy();
                    var settingsOriginal = new CategoryRuntimeSettings(setting.category, defSettingsOriginal.logLevel, defSettingsOriginal.loggerType, defSettingsOriginal.logFormat, defSettingsOriginal.callBackLogger);
                    newRuntimeSettings_1.put(key, settings);
                    newOriginalRuntimeSettings_1.put(key, settingsOriginal);
                }
                else {
                    throw new Error("No setting associated with key=" + key);
                }
            });
            this._categoryRuntimeSettings.clear();
            this._categoryOriginalRuntimeSettings.clear();
            this._categoryRuntimeSettings = newRuntimeSettings_1;
            this._categoryOriginalRuntimeSettings = newOriginalRuntimeSettings_1;
            // Now initialize a new logger and put it on the delegate. Loggers we give out
            // are guaranteed to be wrapped inside the delegate logger.
            this._rootLoggers.values().forEach(function (pair) {
                // Set the new logger type
                pair.y.delegate = _this.createRootLogger(pair.x);
            });
        }
    };
    /**
     * Set new configuration settings for a category (and possibly its child categories)
     * @param config Config
     * @param category Category
     * @param applyChildren True to apply to child categories, defaults to false.
     * @param resetRootLogger Defaults to false. If set to true and if category is a root category it will reset the root logger.
     */
    CategoryServiceImpl.prototype.setConfigurationCategory = function (config, category, applyChildren, resetRootLogger) {
        var _this = this;
        if (applyChildren === void 0) { applyChildren = false; }
        if (resetRootLogger === void 0) { resetRootLogger = false; }
        var categorySettings = this.getCategorySettings(category);
        if (categorySettings === null) {
            throw new Error("Given category is not registered: " + category.name);
        }
        categorySettings.logLevel = config.logLevel;
        categorySettings.loggerType = config.loggerType;
        categorySettings.logFormat = config.logFormat;
        categorySettings.callBackLogger = config.callBackLogger;
        // Apply the settings to children recursive if requested
        if (applyChildren) {
            category.children.forEach(function (child) {
                _this.setConfigurationCategory(config, child, applyChildren, resetRootLogger);
            });
        }
        if (resetRootLogger && this.rootCategoryExists(category)) {
            var tupleLogger = this._rootLoggers.get(category.name);
            if (tupleLogger !== null) {
                tupleLogger.y.delegate = this.createRootLogger(tupleLogger.x);
            }
        }
    };
    CategoryServiceImpl.prototype.registerCategory = function (category) {
        if (category == null || category === undefined) {
            throw new Error("Category CANNOT be null");
        }
        var parent = category.parent;
        if (parent == null) {
            // Register the root category
            for (var _i = 0, _a = this._rootCategories; _i < _a.length; _i++) {
                var rootCategory = _a[_i];
                if (rootCategory.name === category.name) {
                    throw new Error("Cannot add this rootCategory with name: " + category.name + ", another root category is already registered with that name.");
                }
            }
            this._rootCategories.push(category);
        }
        this.initializeRuntimeSettingsForCategory(category);
    };
    /**
     * Used to enable integration with chrome extension. Do not use manually, the
     * extension and the logger framework deal with this.
     */
    CategoryServiceImpl.prototype.enableExtensionIntegration = function () {
        var _this = this;
        this._rootLoggers.values().forEach(function (pair) {
            // Set the new logger type if needed.
            var delegateLogger = pair.y;
            if (!(delegateLogger instanceof CategoryExtensionLoggerImpl_1.CategoryExtensionLoggerImpl)) {
                /* tslint:disable:no-console */
                console.log("Reconfiguring root logger for root category: " + pair.x.name);
                /* tslint:enable:no-console */
                pair.y.delegate = new CategoryExtensionLoggerImpl_1.CategoryExtensionLoggerImpl(pair.x, _this);
            }
        });
    };
    /**
     * Return all root categories currently registered.
     */
    CategoryServiceImpl.prototype.getRootCategories = function () {
        return this._rootCategories.slice(0);
    };
    /**
     * Return Category by id
     * @param id The id of the category to find
     * @returns {Category} or null if not found
     */
    CategoryServiceImpl.prototype.getCategoryById = function (id) {
        var result = this._categoryRuntimeSettings.values().filter(function (cat) { return cat.category.id === id; })
            .map(function (cat) { return cat.category; });
        if (result.length === 1) {
            return result[0];
        }
        return null;
    };
    CategoryServiceImpl.prototype.initializeRuntimeSettingsForCategory = function (category) {
        var settings = this._categoryRuntimeSettings.get(category.getCategoryPath());
        if (settings !== null) {
            throw new Error("Category with path: " + category.getCategoryPath() + " is already registered?");
        }
        // Passing the callback is not really needed for child categories, but don't really care.
        var defSettings = this._defaultConfig.copy();
        settings = new CategoryRuntimeSettings(category, defSettings.logLevel, defSettings.loggerType, defSettings.logFormat, defSettings.callBackLogger);
        var defSettingsOriginal = this._defaultConfig.copy();
        var settingsOriginal = new CategoryRuntimeSettings(category, defSettingsOriginal.logLevel, defSettingsOriginal.loggerType, defSettingsOriginal.logFormat, defSettingsOriginal.callBackLogger);
        this._categoryRuntimeSettings.put(category.getCategoryPath(), settings);
        this._categoryOriginalRuntimeSettings.put(category.getCategoryPath(), settingsOriginal);
    };
    CategoryServiceImpl.prototype.rootCategoryExists = function (rootCategory) {
        if (rootCategory == null || rootCategory === undefined) {
            throw new Error("Root category CANNOT be null");
        }
        var parent = rootCategory.parent;
        if (parent != null) {
            throw new Error("Parent must be null for a root category");
        }
        return this._rootCategories.indexOf(rootCategory) !== -1;
    };
    CategoryServiceImpl.prototype.createRootLogger = function (category) {
        // Default is always a console logger
        switch (this._defaultConfig.loggerType) {
            case LoggerOptions_1.LoggerType.Console:
                return new CategoryConsoleLoggerImpl_1.CategoryConsoleLoggerImpl(category, this);
            case LoggerOptions_1.LoggerType.MessageBuffer:
                return new CategoryMessageBufferImpl_1.CategoryMessageBufferLoggerImpl(category, this);
            case LoggerOptions_1.LoggerType.Custom:
                if (this._defaultConfig.callBackLogger == null) {
                    throw new Error("Cannot create custom logger, custom callback is null");
                }
                else {
                    return this._defaultConfig.callBackLogger(category, this);
                }
            default:
                throw new Error("Cannot create a Logger for LoggerType: " + this._defaultConfig.loggerType);
        }
    };
    return CategoryServiceImpl;
}());
// Singleton category service, used by CategoryServiceFactory as well as Categories.
// Loaded on demand. Do NOT change as webpack may pack things in wrong order otherwise.
CategoryServiceImpl._INSTANCE = null;
exports.CategoryServiceImpl = CategoryServiceImpl;
/**
 * Categorized service for logging, where logging is bound to categories which
 * can log horizontally through specific application logic (services, group(s) of components etc).
 * For the standard way of logging like most frameworks do these days, use LFService instead.
 * If you want fine grained control to divide sections of your application in
 * logical units to enable/disable logging for, this is the service you want to use instead.
 * Also for this type a browser plugin will be available.
 */
var CategoryServiceFactory = (function () {
    function CategoryServiceFactory() {
        // Private constructor.
    }
    /**
     * Return a CategoryLogger for given ROOT category (thus has no parent).
     * You can only retrieve loggers for their root, when logging
     * you specify to log for what (child)categories.
     * @param root Category root (has no parent)
     * @returns {CategoryLogger}
     */
    CategoryServiceFactory.getLogger = function (root) {
        return CategoryServiceImpl.getInstance().getLogger(root);
    };
    /**
     * Clears everything, any registered (root)categories and loggers
     * are discarded. Resets to default configuration.
     */
    CategoryServiceFactory.clear = function () {
        return CategoryServiceImpl.getInstance().clear();
    };
    /**
     * Set the default configuration. New root loggers created get this
     * applied. If you want to reset all current loggers to have this
     * applied as well, pass in reset=true (the default is false). All
     * categories runtimesettings will be reset then as well.
     * @param config The new default configuration
     * @param reset If true, will reset *all* runtimesettings for all loggers/categories to these.
     */
    CategoryServiceFactory.setDefaultConfiguration = function (config, reset) {
        if (reset === void 0) { reset = false; }
        CategoryServiceImpl.getInstance().setDefaultConfiguration(config, reset);
    };
    /**
     * Set new configuration settings for a category (and possibly its child categories)
     * @param config Config
     * @param category Category
     * @param applyChildren True to apply to child categories, defaults to false.
     * @param resetRootLogger Defaults to false. If set to true and if category is a root category it will reset the root logger.
     */
    CategoryServiceFactory.setConfigurationCategory = function (config, category, applyChildren, resetRootLogger) {
        if (applyChildren === void 0) { applyChildren = false; }
        if (resetRootLogger === void 0) { resetRootLogger = false; }
        CategoryServiceImpl.getInstance().setConfigurationCategory(config, category, applyChildren, resetRootLogger);
    };
    /**
     * Return RuntimeSettings to retrieve information about
     * RuntimeSettings for categories.
     * @returns {RuntimeSettings}
     */
    CategoryServiceFactory.getRuntimeSettings = function () {
        return CategoryServiceImpl.getInstance();
    };
    return CategoryServiceFactory;
}());
exports.CategoryServiceFactory = CategoryServiceFactory;
//# sourceMappingURL=CategoryService.js.map