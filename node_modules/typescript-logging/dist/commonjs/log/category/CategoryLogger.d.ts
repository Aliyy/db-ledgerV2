import { LogLevel } from "../LoggerOptions";
/**
 * Category for use with categorized logging.
 * At minimum you need one category, which will serve as the root category.
 * You can create child categories (like a tree). You can have multiple root
 * categories.
 */
export declare class Category {
    private static currentId;
    private _id;
    private _name;
    private _parent;
    private _children;
    private _logLevel;
    constructor(name: string, parent?: Category | null);
    readonly name: string;
    readonly parent: Category | null;
    readonly children: Category[];
    readonly logLevel: LogLevel;
    getCategoryPath(): string;
    /**
     * Returns the id for this category (this
     * is for internal purposes only).
     * @returns {number} Id
     */
    readonly id: number;
    private static nextId();
}
/**
 * CategoryLogger. Methods ending with c are closure methods and will only be called when
 * they need to be logged, this may be cheaper if some of your logging is expensive (network/calculating wise).
 */
export interface CategoryLogger {
    trace(msg: string, ...categories: Category[]): void;
    debug(msg: string, ...categories: Category[]): void;
    info(msg: string, ...categories: Category[]): void;
    warn(msg: string, ...categories: Category[]): void;
    error(msg: string, error: Error | null, ...categories: Category[]): void;
    fatal(msg: string, error: Error | null, ...categories: Category[]): void;
    /**
     * This is a special opinionated way to log, that an exception (Error)
     * occurred, but your code dealt with it in a proper way. That way
     * we can say, there was an Error/Exception but we resolved it.
     * This will be logged as: Error (resolved) in the log.
     * @param msg Message
     * @param error Error
     * @param categories Categories to log for
     */
    resolved(msg: string, error: Error | null, ...categories: Category[]): void;
    log(level: LogLevel, msg: string, error: Error | null, ...categories: Category[]): void;
    tracec(msg: () => string, ...categories: Category[]): void;
    debugc(msg: () => string, ...categories: Category[]): void;
    infoc(msg: () => string, ...categories: Category[]): void;
    warnc(msg: () => string, ...categories: Category[]): void;
    errorc(msg: () => string, error: () => Error | null, ...categories: Category[]): void;
    fatalc(msg: () => string, error: () => Error | null, ...categories: Category[]): void;
    /**
     * This is a special opinionated way to log, that an exception (Error)
     * occurred, but your code dealt with it in a proper way. That way
     * we can say, there was an Error/Exception but we resolved it.
     * This will be logged as: Error (resolved) in the log.
     * @param msg Message as closure
     * @param error Error as closure
     * @param categories Categories to log for
     */
    resolvedc(msg: () => string, error: () => Error | null, ...categories: Category[]): void;
    logc(level: LogLevel, msg: () => string, error: () => Error | null, ...categories: Category[]): void;
}
