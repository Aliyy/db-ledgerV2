import { LogLevel } from "../LoggerOptions";
import { LogGroupRule, LogGroupRuntimeSettings } from "./LoggerFactoryService";
import { Logger } from "./Logger";
/**
 * Log message, providing all data for a single message.
 */
export interface LogMessage {
    /**
     * Name of the logger.
     */
    readonly loggerName: string;
    /**
     * Original, unformatted message.
     */
    readonly message: string;
    /**
     * Returns the resolved stack (based on error).
     * Available only when error is present.
     */
    readonly errorAsStack: string | null;
    /**
     * Error when present, or null.
     */
    readonly error: Error | null;
    /**
     * Which LogGroupRule matched for this message.
     */
    readonly logGroupRule: LogGroupRule;
    /**
     * Time for message.
     */
    readonly date: Date;
    /**
     * LogLevel used
     */
    readonly level: LogLevel;
}
/**
 * Abstract base logger, extend to easily implement a custom logger that
 * logs wherever you want. You only need to implement doLog(msg: LogMessage) and
 * log that somewhere (it will contain format and everything else).
 */
export declare abstract class AbstractLogger implements Logger {
    private _logGroupRuntimeSettings;
    private _allMessages;
    protected _name: string;
    protected _open: boolean;
    constructor(name: string, logGroupRuntimeSettings: LogGroupRuntimeSettings);
    readonly name: string;
    trace(msg: string, error?: Error | null): void;
    debug(msg: string, error?: Error | null): void;
    info(msg: string, error?: Error | null): void;
    warn(msg: string, error?: Error | null): void;
    error(msg: string, error?: Error | null): void;
    fatal(msg: string, error?: Error | null): void;
    tracec(msg: () => string, error?: () => Error | null): void;
    debugc(msg: () => string, error?: () => Error | null): void;
    infoc(msg: () => string, error?: () => Error | null): void;
    warnc(msg: () => string, error?: () => Error | null): void;
    errorc(msg: () => string, error?: () => Error | null): void;
    fatalc(msg: () => string, error?: () => Error | null): void;
    isTraceEnabled(): boolean;
    isDebugEnabled(): boolean;
    isInfoEnabled(): boolean;
    isWarnEnabled(): boolean;
    isErrorEnabled(): boolean;
    isFatalEnabled(): boolean;
    getLogLevel(): LogLevel;
    isOpen(): boolean;
    close(): void;
    protected createDefaultLogMessage(msg: LogMessage): string;
    protected abstract doLog(msg: LogMessage): void;
    private _log(level, msg, error?);
    private _logc(level, msg, error?);
    private createMessage(level, msg, date, error?);
    private processMessages();
}
