import { CategoryLogFormat, LoggerType, LogLevel } from "../LoggerOptions";
import { Category, CategoryLogger } from "./CategoryLogger";
/**
 * RuntimeSettings for a category, at runtime these are associated to a category.
 */
export declare class CategoryRuntimeSettings {
    private _category;
    private _logLevel;
    private _loggerType;
    private _logFormat;
    private _callBackLogger;
    constructor(category: Category, logLevel?: LogLevel, loggerType?: LoggerType, logFormat?: CategoryLogFormat, callBackLogger?: ((rootCategory: Category, runtimeSettings: RuntimeSettings) => CategoryLogger) | null);
    readonly category: Category;
    logLevel: LogLevel;
    loggerType: LoggerType;
    logFormat: CategoryLogFormat;
    callBackLogger: ((rootCategory: Category, runtimeSettings: RuntimeSettings) => CategoryLogger) | null;
}
/**
 * Interface for RuntimeSettings related to Categories.
 */
export interface RuntimeSettings {
    /**
     * Get the current live runtimesettings for given category
     * @param category Category
     * @return {CategoryRuntimeSettings} CategoryRuntimeSettings when found, null otherwise.
     */
    getCategorySettings(category: Category): CategoryRuntimeSettings | null;
    /**
     * Returns the original runtimesettings when they were created first, these
     * will never reflect later changes done by logger control
     * @param category Category
     * @return {CategoryRuntimeSettings} CategoryRuntimeSettings when found, null otherwise.
     */
    getOriginalCategorySettings(category: Category): CategoryRuntimeSettings | null;
}
/**
 * Default configuration, can be used to initially set a different default configuration
 * on the CategoryServiceFactory. This will be applied to all categories already registered (or
 * registered in the future). Can also be applied to one Category (and childs).
 */
export declare class CategoryDefaultConfiguration {
    private _logLevel;
    private _loggerType;
    private _logFormat;
    private _callBackLogger;
    /**
     * Create a new instance
     * @param logLevel Log level for all loggers, default is LogLevel.Error
     * @param loggerType Where to log, default is LoggerType.Console
     * @param logFormat What logging format to use, use default instance, for default values see CategoryLogFormat.
     * @param callBackLogger Optional callback, if LoggerType.Custom is used as loggerType. In that case must return a new Logger instance.
     *            It is recommended to extend AbstractCategoryLogger to make your custom logger.
     */
    constructor(logLevel?: LogLevel, loggerType?: LoggerType, logFormat?: CategoryLogFormat, callBackLogger?: ((rootCategory: Category, runtimeSettings: RuntimeSettings) => CategoryLogger) | null);
    readonly logLevel: LogLevel;
    readonly loggerType: LoggerType;
    readonly logFormat: CategoryLogFormat;
    readonly callBackLogger: ((rootCategory: Category, runtimeSettings: RuntimeSettings) => CategoryLogger) | null;
    copy(): CategoryDefaultConfiguration;
}
/**
 * The service (only available as singleton) for all category related stuff as
 * retrieving, registering a logger. You should normally NOT use this,
 * instead use CategoryLoggerFactory which is meant for end users.
 */
export declare class CategoryServiceImpl implements RuntimeSettings {
    private static _INSTANCE;
    private _defaultConfig;
    private _rootCategories;
    private _categoryRuntimeSettings;
    private _categoryOriginalRuntimeSettings;
    private _rootLoggers;
    private constructor();
    static getInstance(): CategoryServiceImpl;
    getLogger(root: Category): CategoryLogger;
    /**
     * Clears everything, including a default configuration you may have set.
     * After this you need to re-register your categories etc.
     */
    clear(): void;
    getCategorySettings(category: Category): CategoryRuntimeSettings | null;
    getOriginalCategorySettings(category: Category): CategoryRuntimeSettings | null;
    /**
     * Set the default configuration. New root loggers created get this
     * applied. If you want to reset all current loggers to have this
     * applied as well, pass in reset=true (the default is false). All
     * categories will be reset then as well.
     * @param config New config
     * @param reset Defaults to false. Set to true to reset all loggers and current runtimesettings.
     */
    setDefaultConfiguration(config: CategoryDefaultConfiguration, reset?: boolean): void;
    /**
     * Set new configuration settings for a category (and possibly its child categories)
     * @param config Config
     * @param category Category
     * @param applyChildren True to apply to child categories, defaults to false.
     * @param resetRootLogger Defaults to false. If set to true and if category is a root category it will reset the root logger.
     */
    setConfigurationCategory(config: CategoryDefaultConfiguration, category: Category, applyChildren?: boolean, resetRootLogger?: boolean): void;
    registerCategory(category: Category): void;
    /**
     * Used to enable integration with chrome extension. Do not use manually, the
     * extension and the logger framework deal with this.
     */
    enableExtensionIntegration(): void;
    /**
     * Return all root categories currently registered.
     */
    getRootCategories(): Category[];
    /**
     * Return Category by id
     * @param id The id of the category to find
     * @returns {Category} or null if not found
     */
    getCategoryById(id: number): Category | null;
    private initializeRuntimeSettingsForCategory(category);
    private rootCategoryExists(rootCategory);
    private createRootLogger(category);
}
/**
 * Categorized service for logging, where logging is bound to categories which
 * can log horizontally through specific application logic (services, group(s) of components etc).
 * For the standard way of logging like most frameworks do these days, use LFService instead.
 * If you want fine grained control to divide sections of your application in
 * logical units to enable/disable logging for, this is the service you want to use instead.
 * Also for this type a browser plugin will be available.
 */
export declare class CategoryServiceFactory {
    private constructor();
    /**
     * Return a CategoryLogger for given ROOT category (thus has no parent).
     * You can only retrieve loggers for their root, when logging
     * you specify to log for what (child)categories.
     * @param root Category root (has no parent)
     * @returns {CategoryLogger}
     */
    static getLogger(root: Category): CategoryLogger;
    /**
     * Clears everything, any registered (root)categories and loggers
     * are discarded. Resets to default configuration.
     */
    static clear(): void;
    /**
     * Set the default configuration. New root loggers created get this
     * applied. If you want to reset all current loggers to have this
     * applied as well, pass in reset=true (the default is false). All
     * categories runtimesettings will be reset then as well.
     * @param config The new default configuration
     * @param reset If true, will reset *all* runtimesettings for all loggers/categories to these.
     */
    static setDefaultConfiguration(config: CategoryDefaultConfiguration, reset?: boolean): void;
    /**
     * Set new configuration settings for a category (and possibly its child categories)
     * @param config Config
     * @param category Category
     * @param applyChildren True to apply to child categories, defaults to false.
     * @param resetRootLogger Defaults to false. If set to true and if category is a root category it will reset the root logger.
     */
    static setConfigurationCategory(config: CategoryDefaultConfiguration, category: Category, applyChildren?: boolean, resetRootLogger?: boolean): void;
    /**
     * Return RuntimeSettings to retrieve information about
     * RuntimeSettings for categories.
     * @returns {RuntimeSettings}
     */
    static getRuntimeSettings(): RuntimeSettings;
}
