import { CategoryLogFormat, LogLevel } from "../LoggerOptions";
import { Category, CategoryLogger } from "./CategoryLogger";
import { RuntimeSettings } from "./CategoryService";
/**
 * Contains information about a single log message.
 */
export interface CategoryLogMessage {
    getMessage(): string;
    /**
     * Returns the resolved stack (based on error).
     * Available only when error is present.
     */
    getErrorAsStack(): string | null;
    getError(): Error | null;
    getCategories(): Category[];
    getDate(): Date;
    getLevel(): LogLevel;
    getLogFormat(): CategoryLogFormat;
    isResolvedErrorMessage(): boolean;
}
/**
 * Abstract category logger, use as your base class for new type of loggers (it
 * saves you a lot of work) and override doLog(CategoryLogMessage). The message argument
 * provides full access to anything related to the logging event.
 * If you just want the standard line of logging, call: this.createDefaultLogMessage(msg) on
 * this class which will return you the formatted log message as string (e.g. the
 * default loggers all use this).
 */
export declare abstract class AbstractCategoryLogger implements CategoryLogger {
    private rootCategory;
    private runtimeSettings;
    private allMessages;
    constructor(rootCategory: Category, runtimeSettings: RuntimeSettings);
    trace(msg: string, ...categories: Category[]): void;
    debug(msg: string, ...categories: Category[]): void;
    info(msg: string, ...categories: Category[]): void;
    warn(msg: string, ...categories: Category[]): void;
    error(msg: string, error: Error, ...categories: Category[]): void;
    fatal(msg: string, error: Error, ...categories: Category[]): void;
    resolved(msg: string, error: Error, ...categories: Category[]): void;
    log(level: LogLevel, msg: string, error: Error, ...categories: Category[]): void;
    tracec(msg: () => string, ...categories: Category[]): void;
    debugc(msg: () => string, ...categories: Category[]): void;
    infoc(msg: () => string, ...categories: Category[]): void;
    warnc(msg: () => string, ...categories: Category[]): void;
    errorc(msg: () => string, error: () => Error, ...categories: Category[]): void;
    fatalc(msg: () => string, error: () => Error, ...categories: Category[]): void;
    resolvedc(msg: () => string, error: () => Error, ...categories: Category[]): void;
    logc(level: LogLevel, msg: () => string, error: () => Error, ...categories: Category[]): void;
    protected getRootCategory(): Category;
    /**
     * Implement this method in your custom logger
     * @param msg Message
     */
    protected abstract doLog(msg: CategoryLogMessage): void;
    protected createDefaultLogMessage(msg: CategoryLogMessage): string;
    private _log(level, msg, error?, resolved?, ...categories);
    private _logc(level, msg, error, resolved?, ...categories);
    private _logInternal(level, msg, error, resolved, ...categories);
    private processMessages();
}
